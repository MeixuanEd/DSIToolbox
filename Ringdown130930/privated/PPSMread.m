function [y,channels,names,units,delay,ppsmpath,ppsmfile,dasfile,pfildat,errmsg]=...
PPSMread(ppsmpath,ppsmfile,dasfile,columns,decfac,xcon);

% PPSMREAD:  PPSM, DAS
% Reads data from files generated by the BPA Portable Power System Monitor (PPSM).
% This function can be used to read and link data from multiple files.
% All files must have the same header information.
%
% Usage:
%
%   [y,channels,names,units,delay,ppsmpath,ppsmfile,dasfile,pfildat,errmsg]=...
%   ppsmread(ppsmpath,ppsmfile,dasfile,columns,decfac,xcon);
%
% Inputs:
%
%   ppsmpath = Path to the directory containing the PPSM files.  Set ppsmpath = []
%              to use the current working directory.
%
%   ppsmfile = PPSM filename matrix.  Each row contains the name of a data file.
%              The names must be listed in the order in which the data files are to
%              be linked.  Set ppsmfile = [] to interactively choose files.
%
%   dasfile  = DAS listing filename.  This should be entered as the complete path to
%              the DAS listing file.  Set dasfile = [] to use the listing that is
%              embedded the PPSM file.  Set dasfile = 'Select' for interactive DAS
%              file selection.
%
%   columns  = Vector specifying data column numbers to read from the PPSM files.
%              Set columns = [] to obtain only channel and name information about
%              the files.  Set columns = 'all' to read all columns.
%
%   decfac   = Factor by which to decimate data columns during import.  Setting
%              decfac to some number greater than one can reduce the possibility
%              of Out of Memory errors when reading long records.  No anti-alias
%              filtering is performed prior to decimation.
%
%   xcon     = Three element control vector.
%              First element is a diagnostics flag for read progress.
%              If xcon(1) == 1; Information about file access errors is printed.
%              If xcon(1) == 0; No diagnostic information is printed.
%              Second element is a scan rate correction switch.
%              If xcon(2) == 1; Scan rate calculated from binary files is forced
%                               to be an integer with two or fewer nonzero digits.
%                               This is often necessary for phasor data.  This
%                               option is experimental and can produce errors.
%              If xcon(2) == 0; No scan rate adjustment.
%              Third element specifies version of binary file format.
%              If xcon(3) == 1; Files are in PPSM 1 format.
%              If xcon(3) == 2; Files are in PPSM 2 format.
%
% Outputs:
%
%   y        = Matrix containing selected data columns.  First column is time.
%
%   channels = Vector containing channels numbers for data columns.
%
%   names    = Matrix containing channel names.  Each row corresponds to a channel.
%
%   units    = Matrix containing channel measurement units.
%
%   delay    = Vector of delay times to add to time column to obtain the actual
%              sample times for each data column.  When interval scanning is used,
%              these are all set to zero.  When non-interval scanning is used,
%              these represent the time between the time stamp for a row and the
%              actual time a sample in that row was acquired.
%
%   ppsmpath = Path to directory containing the PPSM files.
%
%   ppsmfile = PPSM filename matrix.
%
%   dasfile  = Complete path to the DAS listing file.
%
%   pfildat  = Matrix with data about PPSM files.  Each row contains data for the
%              corresponding file.  Column 1 contains the file's time stamp in
%              seconds since January 1, 1904.  Column 2 contains the number of
%              samples per channel before decimation.  Column 3 contains the
%              sample period before decimation.  Column 4 contains the last
%              integer in each file header.
%
%   errmsg   = Error message if runtime error occurs.  If this argument is not
%              present in the function call, a MATLAB error results.

% By Jeff M. Johnson, Pacific Northwest National Laboratory.
% Date:  December 19, 1996.
%
% Copyright (c) 1995-2013 Battelle Memorial Institute.  The Government
% retains a paid-up nonexclusive, irrevocable worldwide license to
% reproduce, prepare derivative works, perform publicly and display
% publicly by or for the Government, including the right to distribute
% to other Government contractors.
%
% $Id$

% Initialize output arguments
if nargout
  y=[]; channels=''; names=''; units=''; delay=[]; pfildat=[]; errmsg='';
end

% Print RCSID stamp and copyright
if nargin==1 & ischar(ppsmpath) & strcmp(ppsmpath,'rcsid')
  ppsmpath=''; ppsmfile=''; dasfile='';
  fprintf(1,['\n$Id$\n\n' ...
    'Copyright (c) 1995-2013 Battelle Memorial Institute.  The Government\n' ...
    'retains a paid-up nonexclusive, irrevocable worldwide license to\n' ...
    'reproduce, prepare derivative works, perform publicly and display\n' ...
    'publicly by or for the Government, including the right to distribute\n' ...
    'to other Government contractors.\n\n' ...
    'Date of last source code modification:  04/26/2000 (JMJ)\n\n']);
 return
end

% Check input arguments
mxnargout=10;
error(nargchk(5,6,nargin));
if ~isempty(ppsmpath) & ~ischar(ppsmpath)
  errmsg='PPSM pathname must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if ~isempty(ppsmfile) & ~ischar(ppsmfile)
  errmsg='PPSM filename must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if ~isempty(dasfile) & ~ischar(dasfile)
  errmsg='DAS filename must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if length(decfac)~=1
  errmsg='Decimation factor must be a scalar';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if decfac<1 | decfac-fix(decfac)>eps
  errmsg='Decimation factor must be an integer greater than 0.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if nargin==5
  verbose=0; correctfs=0; ppsmfmt=0;
else
  xconl=length(xcon);
  if xconl>=1; verbose=xcon(1); else; verbose=0; end
  if xconl>=2; correctfs=xcon(2); else; correctfs=0; end
  if xconl>=3; ppsmfmt=xcon(3); else; ppsmfmt=0; end
end
if ppsmfmt~=0 & ppsmfmt~=1 & ppsmfmt~=2; ppsmfmt=0; end

% Platform dependent file path separator and end-of-line character.
c=computer;
if strcmp(c(1:2),'PC')
  fsep='\'; eol1=13; eol2=10;
elseif strcmp(c(1:2),'MA')
  fsep=':'; eol1=13; eol2=10;
else
  fsep='/'; eol1=10; eol2=13;
end
tab=9;

% Make sure ppsm path ends with the separator.
if ~isempty(ppsmpath)
  if ppsmpath(end)~=fsep; ppsmpath=[ppsmpath fsep]; end
end

%==================================================================================
% If no PPSM filename was specified, prompt the user to select files to read and
% link.  This process is terminated when the user presses the 'Cancel' button.
% If PPSM filenames were specified, prepend the path to the filenames.

ppsmfilem=[];
if isempty(ppsmfile)
  nnfiles=0; p=ppsmpath;
  while 1
    suf=rem(nnfiles+1,10);
    strng=nnfiles<9 | nnfiles>19;
    if suf==1 & strng
      prompt=sprintf('Select %dst PPSM file.  Press Cancel to end.',nnfiles+1);
    elseif suf==2 & strng
      prompt=sprintf('Select %dnd PPSM file.  Press Cancel to end.',nnfiles+1);
    elseif suf==3 & strng
      prompt=sprintf('Select %drd PPSM file.  Press Cancel to end.',nnfiles+1);
    else
      prompt=sprintf('Select %dth PPSM file.  Press Cancel to end.',nnfiles+1);
    end
    [n,p]=uigetfile([p '*.*'],prompt); if n==0; break; end; nnfiles=nnfiles+1;
    if nnfiles==1; ppsmfilem=[p n]; else; ppsmfilem=str2mat(ppsmfilem,[p n]); end
  end
else
  for ii=1:size(ppsmfile,1)
    ind1=find(ppsmfile(ii,:)==fsep);
    if isempty(ind1)
      p=[]; n=deblank(ppsmfile(ii,:));
    else
      ind1=ind1(end); p=ppsmfile(ii,1:ind1); n=deblank(ppsmfile(ii,ind1+1:end));
    end
    if ~isempty(n)
      if exist([ppsmpath p n])==2
        n=[ppsmpath p n];
      else
        [n,p]=uigetfile([ppsmpath '*.*'],['Please find ' n '.']);
        if any(n); n=[p n]; end
      end
      if any(n)
        if isempty(ppsmfilem); ppsmfilem=n; else; ppsmfilem=str2mat(ppsmfilem,n); end
      end
    end
  end
  nnfiles=size(ppsmfilem,1);
end
if ~nnfiles; return; end

%==================================================================================
% Open the files and read the header information.  Make sure that all file
% headers are compatible with that of the first file.
% Numeric format for PPSM files is IEEE big-endian.

timestamps=zeros(nnfiles,1); nnsamples=timestamps; almsubsec=timestamps;
lhdfld=timestamps; datoffsets=timestamps;

for ii=1:nnfiles

  ppsmfilet=deblank(ppsmfilem(ii,:)); [fid,msg]=fopen(ppsmfilet,'r','b');
  if fid<0
    errmsg=['Error opening ' ppsmfilet '.  Error message from MATLAB is "' msg '".'];
    if nargout<mxnargout; error(errmsg); else; return; end
  end

  % Try to determine if this is PPSM 1 or PPSM 2 format
  if ppsmfmt==0
    try
      fread(fid,2,'uint32');
      fread(fid,fread(fid,1,'int32'),'uint16');
      fread(fid,1,'float64');
      fread(fid,fread(fid,1,'int32'),'uint16');
      header4=char(fread(fid,fread(fid,1,'int32'),'char'))';
      if header4>=32 & header4<=126; ppsmfmt=2; else; ppsmfmt=1; end
    catch
      ppsmfmt=1;
    end
    if fseek(fid,0,-1)
      errmsg=['Error reading ' ppsmfilet '.  Unable to re-position file pointer.'];
      fclose(fid); if nargout<mxnargout; error(errmsg); else; return; end
    end
    if verbose; fprintf(1,'Assuming PPSM %d file format.\n',ppsmfmt); end
  end

  % Read the header
  if ppsmfmt==1
    header1=zeros(5,1);
    try
      timestamps(ii)=fread(fid,1,'uint32');             % Time of first sample.
      header1(1)=fread(fid,1,'int16');                  % MIO card bit resolution.
      header1(2)=fread(fid,1,'int16');                  % Timebase number.
      header1(3)=fread(fid,1,'int32');                  % Scan interval.
      header1(4)=fread(fid,1,'int16');                  % Analog input range.
      header1(5)=fread(fid,1,'int16');                  % MIO card polarity.
      header2=fread(fid,fread(fid,1,'int32'),'int16');  % Channel list.
      header3=fread(fid,fread(fid,1,'int32'),'int16');  % Gains.
      nnsamples(ii)=fread(fid,1,'int32');               % Samples per channel.
      nnchannels=fread(fid,1,'int32');                  % Number of channels.
      almsubsec(ii)=fread(fid,1,'int32');               % Alarms/Subseconds.
      header4=fread(fid,fread(fid,1,'int32'),'char');   % DAS listing string.
      lhdfld(ii)=fread(fid,1,'int32');                  % Last header field.
      datoffsets(ii)=ftell(fid);                        % Offset of data.
    catch
      errmsg=['Error reading ' ppsmfilet '.  One or more bad fields in header.'];
    end
    fclose(fid);
    if ~isempty(errmsg)
      if nargout<mxnargout; error(errmsg); else; return; end
    end
    if ii==1
      headerf=header1; timebase=headerf(2); channels=header2; gains=header3;
      daslist=header4; nn1=nnchannels; intscale=2^headerf(1); inrange=headerf(4);
      switch timebase
        case  0, dt=1e-6*headerf(3);
        case  1, dt=1e-6*headerf(3);
        case  2, dt=1e-5*headerf(3);
        case  3, dt=1e-4*headerf(3);
        case  4, dt=1e-3*headerf(3);
        case  5, dt=1e-2*headerf(3);
        case  6, dt=1e-6*nn1*headerf(3);
        case  7, dt=1e-6*nn1*headerf(3);
        case  8, dt=1e-5*nn1*headerf(3);
        case  9, dt=1e-4*nn1*headerf(3);
        case 10, dt=1e-3*nn1*headerf(3);
        case 11, dt=1e-2*nn1*headerf(3);
        otherwise, ...
          errmsg=['Timebase number in ' ppsmfilet ' out of range.'], ...
          if nargout<mxnargout; error(errmsg); else; return; end;
      end
      if headerf(5)==1; intformat='int16'; else; intformat='uint16'; end
    else
      if any(header1~=headerf)
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have incompatible header information.'];
      end
      if ~isempty(errmsg) & ~strcmp(header2,channels)
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different channel lists.'];
      end
      if ~isempty(errmsg) & ~strcmp(header3,gains)
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different channel gains arrays.'];
      end
      if ~isempty(errmsg) & nnchannels~=nn1
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different numbers of channels.'];
      end
      if ~isempty(errmsg) & ~strcmp(header4,daslist)
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' use different DAS listings.'];
      end
      if ~isempty(errmsg)
        if nargout<mxnargout; error(errmsg); else; return; end
      end
    end
  else
    try
      timestamps(ii)=fread(fid,1,'uint32');             % Time of first sample.
      almsubsec(ii)=fread(fid,1,'int32');               % Microseconds.
      header2=fread(fid,fread(fid,1,'int32'),'uint16'); % Scans/sec array.
      timespan=fread(fid,1,'float64');                  % File time span.
      header3=fread(fid,fread(fid,1,'int32'),'uint16'); % Number of channels array.
      header4=fread(fid,fread(fid,1,'int32'),'char');   % DAS listing string.
      lhdfld(ii)=fread(fid,1,'uint16');                 % Last header field.
      datoffsets(ii)=ftell(fid);                        % Offset of data.
    catch
      errmsg=['Error reading ' ppsmfilet '.  One or more bad fields in header.'];
    end
    fclose(fid);
    if ~isempty(errmsg) & length(header2)>1
      errmsg=['Error reading ' ppsmfilet '.  Multiple data sets per file not supported.'];
    end
    if ~isempty(errmsg)
      if nargout<mxnargout; error(errmsg); else; return; end
    end
    if ii==1
      intscale=32768; inrange=10; nnsamples(ii)=timespan*header2(1); timebase=-1;
      nnchannels=header3(1); daslist=header4; nn1=nnchannels; dt=1/header2(1);
      intformat='int16';
    else
      if 1/header2(1)~=dt
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' data have different sample rates.'];
      end
      if ~isempty(errmsg) & header3(1)~=nn1
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different numbers of channels.'];
      end
      if ~isempty(errmsg)
        if nargout<mxnargout; error(errmsg); else; return; end
      end
    end
  end

  if datoffsets(ii)<0
    errmsg=['Error reading ' ppsmfilet '.  Unable to locate measured data.'];
    if nargout<mxnargout; error(errmsg); else; return; end
  end

end

% Make sure selected columns are in file.
if isempty(columns)
  readdat=0; columns=1:nnchannels;
else
  readdat=1;
  if strcmp(columns,'all')
    columns=1:nnchannels;
  elseif any(columns<1) | any(columns>nnchannels)
    errmsg='Selected columns are not in PPSM files.';
    if nargout<mxnargout; error(errmsg); else; return; end
  end
end

%==================================================================================
% If no DAS file was specified, open the first PPSM file and attempt to read an
% embedded DAS file.  If this fails, prompt the user to select a DAS file.
% If a DAS file was specified, open and read the file.
% If interactive file selection was chosen, force the user to select a DAS file.
% Open and read that file.

daslist=char(daslist');
if isempty(dasfile)
  ppsmfilet=deblank(ppsmfilem(1,:)); [fid,msg]=fopen(ppsmfilet,'r','b');
  if fid<0
    errmsg=['Error re-opening ' ppsmfilet ...
            '.  Error message from MATLAB is "' msg '".'];
    if nargout<mxnargout; error(errmsg); else; return; end
  end
  eod=datoffsets(1)+2*(nnsamples(1)*nn1); continue0=1;
  if fseek(fid,eod,-1)
    continue0=0;
    if verbose
      fprintf(1,'Error reading embedded DAS listing:  ');
      fprintf(1,'Unable to position file pointer past end of data.\n');
    end
  end

  % Read the rest of the file and search for the string <dot>Listing<dot>.
  % <dot> is the Macintosh dot symbol and has the value A5h or 165d.
  if continue0
    [dascont,daslength]=fread(fid,inf); dascont=char(dascont'); fclose(fid);
    listloc=findstr(dascont,char([165 76 105 115 116 105 110 103 165]))+9;
    if isempty(listloc); continue0=0; elseif listloc>daslength; continue0=0; end
    if verbose & ~continue0
      disp('Warning:  No embedded DAS listing information found.');
    end
  end

  % Search for the next dot symbol after <dot>Listing<dot>.  This signifies
  % the end of the listing string.  Search for the first channel number.
  if continue0
    dotloc=find(dascont(listloc:daslength)==165);
    if isempty(dotloc); dasend=daslength; else; dasend=listloc+dotloc(1)-1; end
    begind=listloc;
    while begind<dasend & (dascont(begind) < '0' | dascont(begind) > '9')
      begind=begind+1;
    end
    if begind==dasend; continue0=0; end
    if verbose & ~continue0
      disp('Warning:  Embedded DAS listing is empty.');
    end
  end
  if continue0; dascont=dascont(begind:dasend); else; dasfile='Select'; end
end
if strcmp(lower(dasfile),'select');
  ind=find(ppsmfilem(1,:)==fsep);
  if isempty(ind); p=[]; else; p=ppsmfilem(1,1:ind(end)); end; reselect=1;
  while reselect
    [n,p]=uigetfile([p '*.*'],['Select DAS listing file:  ' daslist]);
    if n==0; return; end
    dasfile=[p n]; reselect=0;
    for ii=1:nnfiles
      if strcmp(dasfile,ppsmfilem(ii,:))
        errordlg('Selected DAS filename is same as a PPSM filename.','Error');
        reselect=1; break;
      end
    end
  end
else
  if ~isempty(dasfile)
    for ii=1:nnfiles
      if strcmp(dasfile,ppsmfilem(ii,:))
        errmsg='Selected DAS filename is same as a PPSM filename.';
        if nargout<mxnargout; error(errmsg); else; return; end
      end
    end
  end
end

% Open and read the DAS file if an embedded listing was not successfully read.
if isempty(dasfile)
  if verbose; disp(['Used embedded listing:  ' daslist]); end
else
  if verbose
    ind=find(dasfile==fsep);
    if isempty(ind); n=dasfile; else; n=dasfile(ind(end)+1:end); end
    if ~strcmp(n,daslist)
      disp('Warning:  Selected DAS filename is different from that');
      disp('          specified in the data file header.');
      disp(['          DAS file specified in header is ''' daslist '''']);
      disp(['          DAS file selected by user is ''' n '''']);
    end
  end
  [fid,msg]=fopen(dasfile,'r');
  if fid<0
    errmsg=['Error opening DAS file:  Error message from MATLAB is "' msg '".'];
    if nargout<mxnargout; error(errmsg); else; return; end
  end
  [dascont,daslength]=fread(fid,inf); dascont=char(dascont'); fclose(fid);
end

% Read the channel information from the DAS file.
trigloc=findstr(dascont,'Trigger Configuration For'); daslength=length(dascont);
if ~isempty(trigloc); endind=trigloc(1)-1; else; endind=daslength; end
newlines=find(dascont(1:endind)==eol1);
if isempty(newlines); newlines=find(dascont(1:endind)==eol2); end
if newlines(end)<endind; newlines=[newlines endind+1]; end; nnl=length(newlines);
if verbose
  while nnl>1
    endind=min(newlines(nnl),daslength);
    if isspace(dascont(newlines(nnl-1):endind)); nnl=nnl-1; else; break; end
  end
  newlines=newlines(1:nnl);
end
daschannels=NaN*ones(nnl,1); dasscales=daschannels;
dasoffsets=dasscales; dasnames=char(32*ones(nnl,20)); mxnamel=size(dasnames,2);
dasunits=char(32*ones(nnl,4)); mxunitl=size(dasunits,2); begind=1;
for ii=1:nnl
  continue0=1; endind=newlines(ii)-1;
  while dascont(begind) < '0' & dascont(begind) > '9'; begind=begind+1; end
  if begind<endind; tabs=find(dascont(begind:endind)==tab)+begind-1; else tabs=[]; end
  if length(tabs)~=4
    continue0=0;
    if verbose; msg=sprintf('must have 4 tabs, found %d.\n',length(tabs)); end
  end
  if continue0
    chan=sscanf(dascont(begind:tabs(1)-1),'%d');
    if isempty(chan)
       continue0=0; if verbose; msg='error reading channel number.\n'; end
    end
  end
  if continue0
    name=deblank(dascont(tabs(1)+1:tabs(2)-1));
    if isempty(name); name=''; else; name=name(name>31 & name<128); end
    unit=deblank(dascont(tabs(2)+1:tabs(3)-1));
    if isempty(unit); unit=''; else; unit=unit(unit>31 & unit<128); end
    scale=sscanf(dascont(tabs(3)+1:tabs(4)-1),'%g');
    if length(scale)~=1
      continue0=0; if verbose; msg='error reading scale factor.\n'; end
    end
  end
  if continue0
    offset=sscanf(dascont(tabs(4)+1:endind),'%g');
    if length(offset)~=1
      continue0=0; if verbose; msg='error reading offset.\n'; end
    end
  end
  if continue0
    daschannels(ii)=chan; dasscales(ii)=scale; dasoffsets(ii)=offset;
    namel=length(name); unitl=length(unit);
    if namel>mxnamel
      dasnames=[dasnames char(32*ones(nnl,namel-mxnamel))]; mxnamel=namel;
    end
    dasnames(ii,1:namel)=name;
    if unitl>mxunitl
      dasunits=[dasunits char(32*ones(nnl,unitl-mxunitl))]; mxunitl=unitl;
    end
    dasunits(ii,1:unitl)=unit;
  elseif verbose
    fprintf(1,['Error reading DAS listing:  Line %d skipped, ' msg],ii);
  end
  begind=newlines(ii)+1;
end
lchannels=length(channels);
if all(~channels) | lchannels~=nnchannels
  if nnchannels<=nnl
    channels=daschannels(1:nnchannels); daserr=0;
  else
    daserr=1;
    if verbose
      disp('Error:  Not enough channel information in DAS listing.');
      fprintf(1,'Number of channels in PPSM file is %d.\n',nnchannels);
    end
  end
  if ~daserr
    if any(isnan(channels))
      daserr=1;
      if verbose; disp('Error reading DAS listing:'); end
    end
  end
  if daserr
    if verbose
      disp('Listing contents:'); begind=1;
      for ii=1:nnl
        endind=newlines(ii)-1;
        msg=dascont(begind:endind); msg(msg==eol1|msg==eol2)=[]; disp(msg);
        begind=newlines(ii)+1;
      end
    end
    errmsg='Invalid DAS listing.  Use verbose mode for more information.';
    if nargout<mxnargout; error(errmsg); else; return; end
  end
end

% Match the user selected channels to the information in the DAS file.
channels=channels(columns); nnchannels=length(channels);
scales=ones(nnchannels,1); offsets=zeros(nnchannels,1);
names=char(scales*abs('Not found in DAS listing')); mxnamel=size(names,2);
units=char(scales*abs('None')); mxunitl=size(units,2);
for ii=1:nnchannels
  chanloc=find(channels(ii)==daschannels);
  if ~isempty(chanloc)
    unit=deblank(dasunits(chanloc(1),:)); unitl=length(unit);
    name=deblank(dasnames(chanloc(1),:)); namel=length(name)+unitl+3;
    if unitl>mxunitl
      units=[units char(32*ones(nnchannels,unitl-mxunitl))]; mxunitl=unitl;
    end
    if namel>mxnamel
      names=[names char(32*ones(nnchannels,namel-mxnamel))]; mxnamel=namel;
    end
    units(ii,:)=[unit char(32*ones(1,mxunitl-unitl))];
    names(ii,:)=[name ' (' unit ')' char(32*ones(1,mxnamel-namel))];
    scales(ii)=dasscales(chanloc(1)); offsets(ii)=dasoffsets(chanloc(1));
  end
end
names=str2mat('Time (sec)',names); ii=size(names,2);
if abs(names(:,ii))==32
  ii=ii-1; while ii & abs(names(:,ii))==32; ii=ii-1; end
  if ii; names=names(:,1:ii); end
end
units=str2mat('sec',units); ii=size(units,2);
if abs(units(:,ii))==32
  ii=ii-1; while ii & abs(units(:,ii))==32; ii=ii-1; end
  if ii; units=units(:,1:ii); end
end

%==================================================================================
% Form the ppsmpath, ppsmfile, and pfildat output arguments.

ind=find(ppsmfilem(1,:)==fsep);
if nnfiles>1 & ~isempty(ind)
  ind1=find(~all(~diff(abs(ppsmfilem(:,1:ind(end))))));
  if ~isempty(ind1)
    ind=ind1(1);
    while ind; if ppsmfilem(1,ind)==fsep; break; else; ind=ind-1; end; end
    if ~ind; ind=[]; end
  end
end
if isempty(ind)
  ppsmpath=''; ppsmfile=ppsmfilem;
else
  ind=ind(end); ppsmpath=ppsmfilem(1,1:ind); ppsmfile=ppsmfilem(:,ind+1:end);
end

% Adjust the sample period so that the corresponding sample frequency can
% be expressed as an integer with two or fewer nonzero digits.  This is
% intended to solve a problem with the PPSM binary file header which requires
% the sample frequency be expressed as an integer divisor of a power of 10.
% Comment this line out if it is producing an incorrect sample period.
if correctfs; sc=10^(floor(-log10(dt))-1); dt=1/(sc*floor(1/(dt*sc))); end

pfildat=zeros(nnfiles,4); pfildat(:,1)=timestamps; pfildat(:,2)=nnsamples;
pfildat(:,3)=dt*ones(nnfiles,1); pfildat(:,4)=lhdfld;

%==================================================================================
% Read the binary PPSM data if column numbers were specified.

if ~readdat; return; end

if timebase<6; delay=zeros(1,nnchannels); else; delay=dt*decfac*(columns-1); end
timestamps=timestamps-timestamps(1);

y=zeros(fix(sum(nnsamples)/decfac),nnchannels+1);

% Loop to read files:  If the entire files are to be read, use a quick read.
% If not all columns are to be read, use a second for loop.
if nn1==nnchannels & all(diff(columns)==1) & decfac==1  % Quick read
  yrow0=0;
  for ii=1:nnfiles
    ind1=yrow0+(1:nnsamples(ii)); y(ind1,1)=timestamps(ii)+dt*(0:nnsamples(ii)-1)';
    ppsmfilet=deblank(ppsmfilem(ii,:)); [fid,msg]=fopen(ppsmfilet,'r','b');
    if fid<0
      errmsg=['Error re-opening ' ppsmfilet ...
              '.  Error message from MATLAB is "' msg '".'];
      if nargout<mxnargout; error(errmsg); else; return; end
    end
    if verbose; disp(['Reading ' ppsmfilet]); end
    if fseek(fid,datoffsets(ii),-1)<0
      errmsg=['Error reading ' ppsmfilet ...
              '.  Unable to position file pointer to location of data.'];
      fclose(fid);
      if nargout<mxnargout; error(errmsg); else; return; end
    end
    [ytemp,count]=fread(fid,[nnchannels nnsamples(ii)],intformat); fclose(fid);
    if count<nnchannels*nnsamples(ii)-1
      errmsg=['Error reading ' ppsmfilet ...
              '.  File does not contain number of samples indicated in header.'];
      if nargout<mxnargout; error(errmsg); else; return; end
    end
    for jj=1:nnchannels
      y(ind1,jj+1)=scales(jj)*inrange/intscale*ytemp(jj,:)'+offsets(jj);
    end
    yrow0=yrow0+nnsamples(ii);
  end
else                                                    % Read columns individually
  skip=2*(decfac*nn1-1); dtf=dt*decfac; yrow0=0; rowskip=0;
  for ii=1:nnfiles
    if rowskip+1<=nnsamples(ii)
      nnsamplef=fix((nnsamples(ii)-rowskip-1)/decfac)+1; byteskip=2*nn1*rowskip;
      ind1=yrow0+(1:nnsamplef);
      y(ind1,1)=timestamps(ii)+dt*rowskip+dtf*(0:nnsamplef-1)';
      ppsmfilet=deblank(ppsmfilem(ii,:)); [fid,msg]=fopen(ppsmfilet,'r','b');
      if fid<0
        errmsg=['Error re-opening ' ppsmfilet ...
                '.  Error message from MATLAB is "' msg '".'];
        if nargout<mxnargout; error(errmsg); else; return; end
      end
      if verbose; disp(['Reading ' ppsmfilet]); end
      for jj=1:nnchannels
        if fseek(fid,datoffsets(ii)+2*(columns(jj)-1)+byteskip,-1)<0
          errmsg=['Error reading ' ppsmfilet ...
                  '.  Unable to position file pointer to location of data.'];
          fclose(fid);
          if nargout<mxnargout; error(errmsg); else; return; end
        end
        [ytemp,count]=fread(fid,[1 nnsamplef],intformat,skip);
        if count<nnsamplef-1
          errmsg=['Error reading ' ppsmfilet ...
                  '.  File does not contain number of samples indicated in header.'];
          fclose(fid);
          if nargout<mxnargout; error(errmsg); else; return; end
        end
        y(ind1,jj+1)=scales(jj)*inrange/intscale*ytemp'+offsets(jj);
      end
      fclose(fid);
      yrow0=yrow0+nnsamplef; rowskip=rowskip+decfac*nnsamplef-nnsamples(ii);
    else
      rowskip=rowskip-nnsamples(ii);
      if verbose; disp(['Skipping ' deblank(ppsmfilem(ii,:))]); end
    end
  end
end
