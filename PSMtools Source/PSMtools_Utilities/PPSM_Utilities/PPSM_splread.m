function [y,channels,names,units,delay,ppsmpath,ppsmfile,dasfile,pfildat,errmsg]=...
PPSM_splread(ppsmpath,ppsmfile,dasfile,columns,decfac,xcon);

% PPSM_splREAD:  PPSM, DAS
% Reads data from files generated by the BPA Portable Power System Monitor (PPSM) in 
% a special format (.mat).
% This function can be used to read and link data from multiple files.
% All files must have the same header information.
%
% Usage:
%
%   [y,channels,names,units,delay,ppsmpath,ppsmfile,dasfile,pfildat,errmsg]=...
%   ppsmread(ppsmpath,ppsmfile,dasfile,columns,decfac,xcon);
%
% Inputs:
%
%   ppsmpath = Path to the directory containing the PPSM files.  Set ppsmpath = []
%              to use the current working directory.
%
%   ppsmfile = PPSM filename matrix.  Each row contains the name of a data file.
%              The names must be listed in the order in which the data files are to
%              be linked.  Set ppsmfile = [] to interactively choose files.
%
%   dasfile  = DAS listing filename.  This should be entered as the complete path to
%              the DAS listing file.  Set dasfile = [] to use the listing that is
%              embedded the PPSM file.  Set dasfile = 'Select' for interactive DAS
%              file selection.
%
%   columns  = Vector specifying data column numbers to read from the PPSM files.
%              Set columns = [] to obtain only channel and name information about
%              the files.  Set columns = 'all' to read all columns.
%
%   decfac   = Factor by which to decimate data columns during import.  Setting
%              decfac to some number greater than one can reduce the possibility
%              of Out of Memory errors when reading long records.  No anti-alias
%              filtering is performed prior to decimation.
%
%   xcon     = Three element control vector.
%              First element is a diagnostics flag for read progress.
%              If xcon(1) == 1; Information about file access errors is printed.
%              If xcon(1) == 0; No diagnostic information is printed.
%              Second element is a scan rate correction switch.
%              If xcon(2) == 1; Scan rate calculated from binary files is forced
%                               to be an integer with two or fewer nonzero digits.
%                               This is often necessary for phasor data.  This
%                               option is experimental and can produce errors.
%              If xcon(2) == 0; No scan rate adjustment.
%              Third element specifies version of binary file format.
%              If xcon(3) == 1; Files are in PPSM 1 format.
%              If xcon(3) == 2; Files are in PPSM 2 format.
%
% Outputs:
%
%   y        = Matrix containing selected data columns.  First column is time.
%
%   channels = Vector containing channels numbers for data columns.
%
%   names    = Matrix containing channel names.  Each row corresponds to a channel.
%
%   units    = Matrix containing channel measurement units.
%
%   delay    = Vector of delay times to add to time column to obtain the actual
%              sample times for each data column.  When interval scanning is used,
%              these are all set to zero.  When non-interval scanning is used,
%              these represent the time between the time stamp for a row and the
%              actual time a sample in that row was acquired.
%
%   ppsmpath = Path to directory containing the PPSM files.
%
%   ppsmfile = PPSM filename matrix.
%
%   dasfile  = Complete path to the DAS listing file.
%
%   pfildat  = Matrix with data about PPSM files.  Each row contains data for the
%              corresponding file.  Column 1 contains the file's time stamp in
%              seconds since January 1, 1904.  Column 2 contains the number of
%              samples per channel before decimation.  Column 3 contains the
%              sample period before decimation.  Column 4 contains the last
%              integer in each file header.
%
%   errmsg   = Error message if runtime error occurs.  If this argument is not
%              present in the function call, a MATLAB error results.
%
% Modified 06/22/04   jfh     

% By Henry Huang, Pacific Northwest National Laboratory.
% Date:  February 16, 2004.
% (based on ppsmread.m by Jeff Johnson.)
%
% Copyright (c) 1995-2004 Battelle Memorial Institute.  The Government
% retains a paid-up nonexclusive, irrevocable worldwide license to
% reproduce, prepare derivative works, perform publicly and display
% publicly by or for the Government, including the right to distribute
% to other Government contractors.
%
% $Id$

FNname='ppsm_splread';

% Initialize output arguments
if nargout
  y=[]; channels=''; names=''; units=''; delay=[]; pfildat=[]; errmsg='';
end

% Print RCSID stamp and copyright
if nargin==1 & ischar(ppsmpath) & strcmp(ppsmpath,'rcsid')
  ppsmpath=''; ppsmfile=''; dasfile='';
  fprintf(1,['\n$Id$\n\n' ...
    'Copyright (c) 1995-2004 Battelle Memorial Institute.  The Government\n' ...
    'retains a paid-up nonexclusive, irrevocable worldwide license to\n' ...
    'reproduce, prepare derivative works, perform publicly and display\n' ...
    'publicly by or for the Government, including the right to distribute\n' ...
    'to other Government contractors.\n\n' ...
    'Date of last source code modification:  02/16/2004 (HZH)\n\n']);
 return
end

% Check input arguments
mxnargout=10;
error(nargchk(5,6,nargin));
if ~isempty(ppsmpath) & ~ischar(ppsmpath)
  errmsg='PPSM pathname must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if ~isempty(ppsmfile) & ~ischar(ppsmfile)
  errmsg='PPSM filename must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if ~isempty(dasfile) & ~ischar(dasfile)
  errmsg='DAS filename must be empty or be a string.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if length(decfac)~=1
  errmsg='Decimation factor must be a scalar';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if decfac<1 | decfac-fix(decfac)>eps
  errmsg='Decimation factor must be an integer greater than 0.';
  if nargout<mxnargout; error(errmsg); else; return; end
end
if nargin==5
  verbose=0; correctfs=0; ppsmfmt=0;
else
  xconl=length(xcon);
  if xconl>=1; verbose=xcon(1); else; verbose=0; end
  if xconl>=2; correctfs=xcon(2); else; correctfs=0; end
  if xconl>=3; ppsmfmt=xcon(3); else; ppsmfmt=0; end
end
if ppsmfmt~=0 & ppsmfmt~=1 & ppsmfmt~=2; ppsmfmt=0; end

% Platform dependent file path separator and end-of-line character.
c=computer;
if strcmp(c(1:2),'PC')
  fsep='\'; eol1=13; eol2=10;
elseif strcmp(c(1:2),'MA')
  fsep=':'; eol1=13; eol2=10;
else
  fsep='/'; eol1=10; eol2=13;
end
tab=9;

% Make sure ppsm path ends with the separator.
if ~isempty(ppsmpath)
  if ppsmpath(end)~=fsep; ppsmpath=[ppsmpath fsep]; end
end

%==================================================================================
% If no PPSM filename was specified, prompt the user to select files to read and
% link.  This process is terminated when the user presses the 'Cancel' button.
% If PPSM filenames were specified, prepend the path to the filenames.

ppsmfilem=[];
if isempty(ppsmfile)
  nnfiles=0; p=ppsmpath;
  while 1
    suf=rem(nnfiles+1,10);
    strng=nnfiles<9 | nnfiles>19;
    if suf==1 & strng
      prompt=sprintf('Select %dst PPSM file.  Press Cancel to end.',nnfiles+1);
    elseif suf==2 & strng
      prompt=sprintf('Select %dnd PPSM file.  Press Cancel to end.',nnfiles+1);
    elseif suf==3 & strng
      prompt=sprintf('Select %drd PPSM file.  Press Cancel to end.',nnfiles+1);
    else
      prompt=sprintf('Select %dth PPSM file.  Press Cancel to end.',nnfiles+1);
    end
    [n,p]=uigetfile([p '*.*'],prompt); if n==0; break; end; nnfiles=nnfiles+1;
    if nnfiles==1; ppsmfilem=[p n]; else; ppsmfilem=str2mat(ppsmfilem,[p n]); end
  end
else
  for ii=1:size(ppsmfile,1)
    ind1=find(ppsmfile(ii,:)==fsep);
    if isempty(ind1)
      p=[]; n=deblank(ppsmfile(ii,:));
    else
      ind1=ind1(end); p=ppsmfile(ii,1:ind1); n=deblank(ppsmfile(ii,ind1+1:end));
    end
    if ~isempty(n)
      if exist([ppsmpath p n])==2
        n=[ppsmpath p n];
      else
        [n,p]=uigetfile([ppsmpath '*.*'],['Please find ' n '.']);
        if any(n); n=[p n]; end
      end
      if any(n)
        if isempty(ppsmfilem); ppsmfilem=n; else; ppsmfilem=str2mat(ppsmfilem,n); end
      end
    end
  end
  nnfiles=size(ppsmfilem,1);
end
if ~nnfiles; return; end

%==================================================================================
% Open the files and read the header information.  Make sure that all file
% headers are compatible with that of the first file.
% Numeric format for PPSM files is IEEE big-endian.

timestamps=zeros(nnfiles,1); nnsamples=timestamps; almsubsec=timestamps;
lhdfld=timestamps; datoffsets=timestamps;

for ii=1:nnfiles

  ppsmfilet=deblank(ppsmfilem(ii,:)); [fid,msg]=fopen(ppsmfilet,'r','b'); % test if file exists
  if fid<0
    errmsg=['Error opening ' ppsmfilet '.  Error message from MATLAB is "' msg '".'];
    if nargout<mxnargout; error(errmsg); else; return; end
  end
  fclose(fid);
  
  try
     Data = load(ppsmfilet);       % load .mat file
  catch
    disp(['In ' FNname ': Bad file load -- here is the keyboard'])
    keyboard
  end
  % Read the header
  header1=zeros(5,1);
  if findstr('H',char(Data.FirstPointTimeStamp))
      [yyyy, MM, dd, hh, mm, ss] = strread(char(Data.FirstPointTimeStamp), '%d-%d-%d %dH%dm%fs');  % first timestamp in the format of 2004-01-20 17H12m35s
  elseif findstr('h',char(Data.FirstPointTimeStamp))
      [yyyy, MM, dd, hh, mm, ss] = strread(char(Data.FirstPointTimeStamp), '%d-%d-%d %dh%dm%fs');  % first timestamp in the format of 2004-01-20 17h12m35s
  else
      [yyyy, MM, dd, hh, mm, ss] = strread(lower(char(Data.FirstPointTimeStamp)), '%d-%d-%d %dh%dm%fs');  % first timestamp in the format of 2004-01-20 17h12m35s
  end
  daysecs = 24*3600; %keyboard
  reftime = (datenum(yyyy,MM,dd,hh,mm,ss)-datenum(1904,1,1,0,0,0))*daysecs; %Start of record, seconds since 01/01/1904
  reftime1 = (datenum(yyyy,MM,dd,hh,mm,ss)-datenum(1900,1,1,0,0,0))*daysecs; %Start of record, seconds since 01/01/1904
  timestamps(ii) = reftime;
  disp(['            Initial reference time = ' PSM2Date(reftime1)])
%      header1(1)=fread(fid,1,'int16');                  % MIO card bit resolution.
%      header1(2)=fread(fid,1,'int16');                  % Timebase number.
%      header1(3)=fread(fid,1,'int32');                  % Scan interval.
%      header1(4)=fread(fid,1,'int16');                  % Analog input range.
%      header1(5)=fread(fid,1,'int16');                  % MIO card polarity.
%      header2=fread(fid,fread(fid,1,'int32'),'int16');  % Channel list.
%      header3=fread(fid,fread(fid,1,'int32'),'int16');  % Gains.
  nnsamples(ii) = size(Data.TransposedData, 2);               % Samples per channel.
  nnchannels = size(Data.TransposedData, 1);                  % Number of channels.
%      almsubsec(ii)=fread(fid,1,'int32');               % Alarms/Subseconds.
  header4 = char(Data.ListingFileName);   % DAS listing string.
%      lhdfld(ii)=fread(fid,1,'int32');                  % Last header field.
%      datoffsets(ii)=ftell(fid);                        % Offset of data.
  if ii==1
%      headerf=header1; timebase=headerf(2); channels=header2; gains=header3;
      daslist=header4; nn1=nnchannels; 
      dt=1/Data.SampleRate;
%      intscale=2^headerf(1); inrange=headerf(4);
%      switch timebase
%       case  0, dt=1e-6*headerf(3);
%        case  1, dt=1e-6*headerf(3);
%       case  2, dt=1e-5*headerf(3);
%        case  3, dt=1e-4*headerf(3);
%       case  4, dt=1e-3*headerf(3);
%        case  5, dt=1e-2*headerf(3);
%       case  6, dt=1e-6*nn1*headerf(3);
%        case  7, dt=1e-6*nn1*headerf(3);
%       case  8, dt=1e-5*nn1*headerf(3);
%        case  9, dt=1e-4*nn1*headerf(3);
%       case 10, dt=1e-3*nn1*headerf(3);
%        case 11, dt=1e-2*nn1*headerf(3);
%       otherwise, ...
%          errmsg=['Timebase number in ' ppsmfilet ' out of range.'], ...
%          if nargout<mxnargout; error(errmsg); else; return; end;
%     end
%      if headerf(5)==1; intformat='int16'; else; intformat='uint16'; end
  else
%     if any(header1~=headerf)
%        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have incompatible header information.'];
%     end
%     if ~isempty(errmsg) & ~strcmp(header2,channels)
%       errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different channel lists.'];
%      end
%     if ~isempty(errmsg) & ~strcmp(header3,gains)
%        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different channel gains arrays.'];
%     end
      if nnchannels~=nn1
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' have different numbers of channels.'];
      end
      if ~strcmp(header4,daslist)
        errmsg=[ppsmfile1 ' and ' ppsmfilet ' use different DAS listings.'];
      end
      if ~isempty(errmsg)
        if nargout<mxnargout; error(errmsg); else; return; end
      end
  end
end

% Make sure selected columns are in file.
if isempty(columns)
  readdat=0; columns=1:nnchannels;
else
  readdat=1;
  if strcmp(columns,'all')
    columns=1:nnchannels;
  elseif any(columns<1) | any(columns>nnchannels)
    errmsg='Selected columns are not in PPSM files.';
    if nargout<mxnargout; error(errmsg); else; return; end
  end
end

%==================================================================================
% If no DAS file was specified, open the first PPSM file and attempt to read an
% embedded DAS file.  If this fails, prompt the user to select a DAS file.
% If a DAS file was specified, open and read the file.
% If interactive file selection was chosen, force the user to select a DAS file.
% Open and read that file.

if isempty(dasfile)
  dasfile = daslist;
else
  ind=find(dasfile==fsep); if ~isempty(ind); dasfileName=dasfile(ind(end):length(dasfile)); end; 
  ind=find(daslist==fsep); if ~isempty(ind); daslistName=daslist(ind(end):length(daslist)); end; 
  if ~strcmp(dasfile, daslist)      
    disp('Warning:  DAS file is different from the DAS file specified in the PPSM data file!');
    dasfile='Select';
    ind=find(ppsmfilem(1,:)==fsep); if isempty(ind); p=[]; else; p=ppsmfilem(1,1:ind(end)); end; reselect=1;
    while reselect
      [n,p]=uigetfile([p '*.*'],['Select DAS listing file:  ' daslist]);
      if n==0; return; end
      dasfile=[p n]; reselect=0;
    end
  end
end

% Open and read the DAS file 
[fid,msg]=fopen(dasfile,'r');
if fid<0
  errmsg=['Error opening DAS file:  Error message from MATLAB is "' msg '".'];
  if nargout<mxnargout; error(errmsg); else; return; end
end
fclose(fid);
[daschannels,dasnames,dasunits,dasscales,dasoffsets]=textread(dasfile,'%d%s%s%f%f','delimiter','\t');  % DAS file is tab delimited.

% Match the user selected channels to the information in the DAS file.
%channels=channels(columns); 
%Diagnostic for defect in textread
LenthOK=length(daschannels)==length(columns); 
if ~LenthOK
  disp('In ppsm_splread: Length mismatch after TEXTREAD')
  disp('Here is the keyboard'); keyboard
  %columns=1:length(daschannels); return
end
channels=daschannels(columns); 
nnchannels=length(channels);
dasnames=char(dasnames); dasunits=char(dasunits); 
scales=ones(nnchannels,1); offsets=zeros(nnchannels,1);
names=char(scales*abs('Not found in DAS listing')); mxnamel=size(names,2);
units=char(scales*abs('None')); mxunitl=size(units,2);
for ii=1:nnchannels
  chanloc=find(channels(ii)==daschannels);
  if ~isempty(chanloc)
    unit=deblank(dasunits(chanloc(1),:)); unitl=length(unit);
    name=deblank(dasnames(chanloc(1),:)); namel=length(name)+unitl+3;
    if unitl>mxunitl
      units=[units char(32*ones(nnchannels,unitl-mxunitl))]; mxunitl=unitl;
    end
    if namel>mxnamel
      names=[names char(32*ones(nnchannels,namel-mxnamel))]; mxnamel=namel;
    end
    units(ii,:)=[unit char(32*ones(1,mxunitl-unitl))];
    names(ii,:)=[name ' (' unit ')' char(32*ones(1,mxnamel-namel))];
    scales(ii)=dasscales(chanloc(1)); offsets(ii)=dasoffsets(chanloc(1));
  end
end
names=str2mat('Time (sec)',names); ii=size(names,2);
if abs(names(:,ii))==32
  ii=ii-1; while ii & abs(names(:,ii))==32; ii=ii-1; end
  if ii; names=names(:,1:ii); end
end
units=str2mat('sec',units); ii=size(units,2);
if abs(units(:,ii))==32
  ii=ii-1; while ii & abs(units(:,ii))==32; ii=ii-1; end
  if ii; units=units(:,1:ii); end
end

%==================================================================================
% Form the ppsmpath, ppsmfile, and pfildat output arguments.

ind=find(ppsmfilem(1,:)==fsep);
if nnfiles>1 & ~isempty(ind)
  ind1=find(~all(~diff(abs(ppsmfilem(:,1:ind(end))))));
  if ~isempty(ind1)
    ind=ind1(1);
    while ind; if ppsmfilem(1,ind)==fsep; break; else; ind=ind-1; end; end
    if ~ind; ind=[]; end
  end
end
if isempty(ind)
  ppsmpath=''; ppsmfile=ppsmfilem;
else
  ind=ind(end); ppsmpath=ppsmfilem(1,1:ind); ppsmfile=ppsmfilem(:,ind+1:end);
end

% Adjust the sample period so that the corresponding sample frequency can
% be expressed as an integer with two or fewer nonzero digits.  This is
% intended to solve a problem with the PPSM binary file header which requires
% the sample frequency be expressed as an integer divisor of a power of 10.
% Comment this line out if it is producing an incorrect sample period.

%if correctfs; sc=10^(floor(-log10(dt))-1); dt=1/(sc*floor(1/(dt*sc))); end

pfildat=zeros(nnfiles,4); pfildat(:,1)=timestamps; pfildat(:,2)=nnsamples;
pfildat(:,3)=dt*ones(nnfiles,1); pfildat(:,4)=lhdfld;

%==================================================================================
% Read the PPSM special data (.mat) if column numbers were specified.

if ~readdat; return; end

%if timebase<6; delay=zeros(1,nnchannels); else; delay=dt*decfac*(columns-1); end
timestamps=timestamps-timestamps(1);

y = [];
y1 = zeros(fix(nnsamples/decfac),nnchannels+1);
decidx = 1:decfac:nnsamples;        % decimate index

% Loop to read files.
for ii=1:nnfiles
    ppsmfilet=deblank(ppsmfilem(ii,:)); 
    Data = load(ppsmfilet);         % load .mat file
    ytemp = Data.TransposedData;    % all channels
    ytemp = ytemp(columns,decidx);       % extract selected channels 
    y1(:,1) = decidx' * 1/Data.SampleRate;                 % timestamp
    for jj=1:nnchannels
      y1(:,jj+1)=scales(jj)*ytemp(jj,:)'+offsets(jj);
    end
    y = [y; y1];
end
